#include <iostream>
#include <limits>
#include <cstring>

using namespace std;

// sis ir vajadzigs waitForKey() funkcijas darbam
const int MAX_STR_LEN = 100;
char line[MAX_STR_LEN];

MeTree tree;
int choice, val, elem;
int num;

void printTree();
void createPrintRoot();
void addElement();
void deleteElement();
void findElement();
void travelTree();
void reverseTree();
void prinyTreeElementCount();
void deleteTree();

// korektam ievadam
int getIntInput() {
    int num;
    while (true) {
        if (cin >> num) return num;
        cout << "Nepareiza ievade! Ludzu ievadiet veselu skaitli: ";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }
}

class Vertex
{
public:
    int value;
    Vertex* left;
    Vertex* right;

    Vertex(int value) {
        this->value = value;
        left = NULL;
        right = NULL;
    }
};

class MeTree
{
public:
    Vertex* root;

    MeTree() {
    }

    MeTree(Vertex* root) {
        this->root = root;
    }

    ~MeTree() {

        
        cout << "\nKOKS DZESTS -----------------------\n";
    }

    void deleteVertex(Vertex* ver)
    {
        if (!ver) return;
        deleteVertex(ver->left);
        deleteVertex(ver->right);
        if (root == ver) {
            cout << "\nJa kas tu izdzesi sakni --> visu koku.";
            root = NULL;
        }
        delete ver;
    }

    Vertex* getParent(Vertex* childVer, Vertex* cur)
    {
        if (!cur) return NULL;
        if (cur->left == childVer || cur->right == childVer) return cur;

        // atgriz parentu uz augšu lai augšējē mezgli un galu galaa root atgrieztu šo mezglu
        Vertex* parent = getParent(childVer, cur->left);
        if(parent) return parent;
       
        // atgriz parentu uz augšu lai augšējē mezgli un galu galaa root atgrieztu šo mezglu
        parent = getParent(childVer, cur->right); 
        if(parent) return parent;

        return NULL;
    }

    void printTreeAsTree(Vertex* node, int depth = 0) {
        if (!node) return;

        // Print right subtree first (appears above)
        printTreeAsTree(node->right, depth + 1);

        // Print current node with indentation (4 spaces per level)
        for (int i = 0; i < depth; ++i) {
            cout << "    "; // 4 spaces
        }
        cout << node->value << endl;

        // Print left subtree (appears below)
        printTreeAsTree(node->left, depth + 1);
    }

    // Convenience wrapper
    void printTreeAsTree() {
        if (!root) {
            cout << "Tree is empty.\n";
            return;
        }
        printTreeAsTree(root);
    }

    void printTreeInorder(Vertex* cur) {
        if (!cur) return;
        printTreeInorder(cur->left);
        cout << cur->value << "\t";
        printTreeInorder(cur->right);
    }

    void printTreePreorder(Vertex* cur) {
        if (!cur) return;
        cout << cur->value << "\t";
        printTreePreorder(cur->left);
        printTreePreorder(cur->right);
    }

    void printTreePostorder(Vertex* cur) {
        if (!cur) return;
        printTreePostorder(cur->left);
        printTreePostorder(cur->right);
        cout << cur->value << "\t";
    }

    Vertex* getLastVertex(int val)
    {
        Vertex* prev = root;
        Vertex* cursor = root;
        while (cursor)
        {
            prev = cursor;
            if (val < cursor->value)
            {
                cursor = cursor->left;
            }
            else cursor = cursor->right;
        }

        return prev;
    }

    void add(int val)
    {
        Vertex* newNode = new Vertex(val);

        if (!root) root = newNode;
        else {
            Vertex* lastNode = getLastVertex(val);
            if (val < lastNode->value) lastNode->left = newNode;
            else lastNode->right = newNode;
        }
    }

    int getCount(Vertex* cur, int count = 0) {
        if (!cur) return count;
        count++;
        count = getCount(cur->left, count);
        count = getCount(cur->right, count);
        return count;
    }

    Vertex* find(int val, Vertex* cur) {
        if (!cur) return NULL;
        if (cur->value == val) return cur;

        Vertex* found = find(val, cur->left);
        if(found) return found;

        found = find(val, cur->right);
        if (found) return found;

        return NULL;
    }

    void reverse(Vertex* ver)
    {
        if (!ver) return;
        Vertex* temp = ver->left;
        ver->left = ver->right;
        ver->right = temp;

        reverse(ver->left);
        reverse(ver->right);
    }
};

void waitForKey() {
    cout << "\nNospied ENTER, lai turpinatu... ";
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cin.getline(line, MAX_STR_LEN);
}

int main()
{
    cout << "\nAutors: Anastasija Kizika, IT 2. kurss";
    cout << "\nProgrammas nosaukums: Datu struktura - Koks\n\n";
    waitForKey();

    while (true)
    {
        tree = MeTree();

        system("cls");
        cout << "\n-------------MENU-----------------\n";
        cout << "1. Izvadit koku\n";
        cout << "2. Izveidot/izvadit koka sakni\n";
        cout << "3. Pievienot elementu\n";
        cout << "4. Dzest elementu\n";
        cout << "5. Atrast Elementu\n";
        cout << "6. Izvadit koka elementu skaitu\n";
        cout << "7. Apstaigat koku\n";
        cout << "8. Apgriezt koku\n";
        cout << "9. Dzest visu koku\n";
        cout << "0. Iziet\n";
        cout << "Ievadiet jusu izveli: ";
        choice = getIntInput();

        switch (choice)
        {
        case 1:
            printTree();
            break;
        case 2:
            createPrintRoot();
            break;
        case 3:
            addElement();
            break;
        case 4:
            deleteElement();
            break;
        case 5:
            findElement();
            break;
        case 6:
            prinyTreeElementCount();
            break;
        case 7:
            travelTree();
            break;
        case 8:
            reverseTree();
            break;
        case 9:
            deleteTree();
            break;
        case 0:
            cout << "Iziet...\n";
            return 0;
        default:
            cout << "Nepareiza izvele\n";
        }
    }
}

void printTree()
{
    if (tree.root == NULL)  cout << "\nNo sakuma izveideo sakni!!";
    else
    {
        tree.printTreeAsTree();
        cout << "\nKoka elementu skaits: ";
        num = tree.getCount(tree.root);
        cout << num;
    }
    waitForKey();
}

void createPrintRoot()
{
    if (tree.root != NULL) cout << "\nKokam jau ir sakne!! Root = " << tree.root->value;
    else
    {
        cout << "Ievadiet saknes elementu: ";
        val = getIntInput();
        tree.add(val);
    }
    waitForKey();
}

void addElement()
{
    if (tree.root == NULL) cout << "\nNo sakuma izveideo sakni!!";
    else
    {
        cout << "Ievadiet jaunu elementu: ";
        val = getIntInput();
        tree.add(val);
    }
    waitForKey();
}

void deleteElement()
{
    if (tree.root == NULL) cout << "\nNo sakuma izveideo sakni!!";
    else
    {
        tree.printTreeInorder(tree.root);
        cout << "\n\nIevadiet elementu, kuru gribi dzest (tiks dzesti ari visi taa berni): ";
        val = getIntInput();
        Vertex* vertex = tree.find(val, tree.root);
        if (vertex)
        {
            Vertex* parent = tree.getParent(vertex, tree.root);
            if (parent)
            {
                if (parent->left == vertex) parent->left = NULL;
                else if (parent->right == vertex) parent->right = NULL;
            }
            tree.deleteVertex(vertex);
            cout << "\nElments tika veiksmigi dzests!";
        }
        else cout << "\nTada elementa nav!";
    }
    waitForKey();
}

void findElement()
{
    if (tree.root == NULL) cout << "\nNo sakuma izveideo sakni!!";
    else
    {
        tree.printTreeInorder(tree.root);
        cout << "Atrast elementu: ";
        val = getIntInput();
        if (tree.find(val, tree.root)) cout << "\nElements atrast!";
        else  cout << "\nTaada elementa koka nav!";
    }
    waitForKey();
}

void travelTree()
{
    if (tree.root == NULL) cout << "\nNo sakuma izveideo sakni!!";
    else {
        cout << "\nInorder print: ";
        tree.printTreeInorder(tree.root);
        tree.swap(tree.root);
        cout << "\n\nKoks tika apgrizts\n\n";
        cout << "\nInorder print: ";
        tree.printTreeInorder(tree.root);
    }
    waitForKey();
}

void reverseTree()
{
    if (tree.root == NULL) cout << "\nNo sakuma izveideo sakni!!";
    else
    {
        cout << "\nIzvelies koka apstsaigasanas veidu (inorder - 1, preorder - 2, postorder - 3): ";
        val = getIntInput();

        switch (val) {
        case 1:
            tree.printTreeInorder(tree.root);
            break;
        case 2:
            tree.printTreePreorder(tree.root);
            break;
        case 3:
            tree.printTreePostorder(tree.root);
            break;
        default:
            cout << "\nNepareiza izvele!";
            break;
        }
    }
    waitForKey();
}

void prinyTreeElementCount()
{
    if (tree.root == NULL) cout << "\nNo sakuma izveideo sakni!!";
    else
    {
        cout << "Koka elementu skaits: ";
        num = tree.getCount(tree.root);
        cout << num;
    }
    waitForKey();
}

void deleteTree()
{
    if (tree.root == NULL) cout << "\nNo sakuma izveideo sakni!!";
    else tree.deleteVertex(tree.root);
    waitForKey();
}
